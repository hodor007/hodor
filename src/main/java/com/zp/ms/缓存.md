一、缓存

    redis:是一个基于内存的高性能key-value数据库。
        Redis支持五种数据类型：string（字符串，是二进制安全的，可以包含任何数据,比如序列化的对象），hash（哈希,键值对），list（列表），set（集合，和list相比集合set不重复）及zset(sorted set：有序集合)。
      使用Redis有哪些好处？
        (1) 速度快，因为数据存在内存中
        (2) 支持丰富数据类型，支持string，list，set，Zset，hash等        
        (3) 支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行        
        (4) 丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除
      Redis是单进程单线程的？
        答：Redis是单进程单线程的，redis利用队列技术将并发访问变为串行访问，消除了传统数据库串行控制的开销。
      Redis的持久化机制是什么？各自的优缺点？
        Redis提供两种持久化机制RDB和AOF机制:
      
      1）RDB(Redis DataBase)快照方式： 将没存中数据以快照方式写入到二进制文件中， 默认文件为ump.rdb，持久化结束后，用这个临时文件替换上次持久化的文件。 
           优点： 　　
          1.只有一个文件dump.rdb，方便持久化。 　　
          2.容灾性好，一个文件可以保存到安全的磁盘。 　　
          3.性能最大化，fork子进程来完成写操作，让主进程继续处理命令，所以是IO最大化。(使用单独子进程来进行持久化，主进程不会进行任何IO操作，保证了redis的高性能) 4.相对于数据集大时，比AOF的启动效率更高。 
           缺点： 　　
          1.数据安全性低。(RDB是间隔一段时间进行持久化，如果持久化之间redis发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候)
       2）AOF(Append-only file)日志追加方式： redis会将每一个收到的写命令写到文件中，默认，appendonly.aof
           优点： 　　
          1.数据安全，aof持久化可以配置appendfsync属性，有always，每进行一次命令操作就记录到aof文件中一次。 　　
          2.通过append模式写文件，即使中途服务器宕机，可以通过redis-check-aof工具解决数据一致性问题。 　　
          3.AOF机制的rewrite模式。(AOF文件没被rewrite之前（文件过大时会对命令进行合并重写），可以删除其中的某些命令（比如误操作的flushall）) 
           缺点： 　　          
          1.AOF文件比RDB文件大，且恢复速度慢。 　　          
          2.数据集大的时候，比rdb启动效率低。
          
    否使用过Redis集群，集群的原理是什么？
    (1)、Redis Sentinal着眼于高可用，在master宕机时会自动将slave提升为master，继续提供服务。
    (2)、Redis Cluster着眼于扩展性，在单个redis内存不足时，使用Cluster进行分片存储。
    
    Redis 主从复制的过程介绍 https://blog.csdn.net/qq_41724691/article/details/86616266
        当设置好 slave 服务器后， slave 会建立和 master 的连接，然后发送 sync 命令。 第一次同步建立的连接 ，
        master 都会启动一个后台进程，将数据 库快照保存到文件中，同时 master 主进程会开始收集新的写命令并缓存起来。后台进程完 成写文件后，
        master 就发送文件给 slave，slave 将文件保存到磁盘上，然后加载到内存恢复 数据库快照到 slave 上。接着 master 就会把缓存的命令转发给 slave。
        而且后续 master 收到 的写命令都会通过开始建立的连接发送给slave。从master到slave的同步数据的命令和从 客 户端发送的命令使用相同的协议格式。
        当 master和slave的连接断开时slave可以自动重新 建立连接。如果 master 同时收到多个 slave 发来的同步连接命令，只会启动一个进程来写数 据库镜像，
        然后发送给所有 slave。    
        
    Redis最适合的场景？
    （1）、会话缓存（Session Cache） 
     最常用的一种使用Redis的情景是会话缓存（session cache）。用Redis缓存会话比其他存储（如Memcached）的优势在于：Redis提供持久化。当维护一个不是严格要求一致性的缓存时，如果用户的购物车信息全部丢失，大部分人都会不高兴的，现在，他们还会这样吗？ 幸运的是，随着 Redis 这些年的改进，很容易找到怎么恰当的使用Redis来缓存会话的文档。甚至广为人知的商业平台Magento也提供Redis的插件。
    （2）、全页缓存（FPC）
     除基本的会话token之外，Redis还提供很简便的FPC平台。回到一致性问题，即使重启了Redis实例，因为有磁盘的持久化，用户也不会看到页面加载速度的下降，这是一个极大改进，类似PHP本地FPC。 再次以Magento为例，Magento提供一个插件来使用Redis作为全页缓存后端。 此外，对WordPress的用户来说，Pantheon有一个非常好的插件 wp-redis，这个插件能帮助你以最快速度加载你曾浏览过的页面。
    （3）、队列 
     Reids在内存存储引擎领域的一大优点是提供 list 和 set 操作，这使得Redis能作为一个很好的消息队列平台来使用。Redis作为队列使用的操作，就类似于本地程序语言（如Python）对 list 的 push/pop 操作。 如果你快速的在Google中搜索“Redis queues”，你马上就能找到大量的开源项目，这些项目的目的就是利用Redis创建非常好的后端工具，以满足各种队列需求。例如，Celery有一个后台就是使用Redis作为broker，你可以从这里去查看。
    （4），排行榜/计数器 
     Redis在内存中对数字进行递增或递减的操作实现的非常好。集合（Set）和有序集合（Sorted Set）也使得我们在执行这些操作的时候变的非常简单，Redis只是正好提供了这两种数据结构。所以，我们要从排序集合中获取到排名最靠前的10个用户–我们称之为“user_scores”，我们只需要像下面一样执行即可： 当然，这是假定你是根据你用户的分数做递增的排序。如果你想返回用户及用户的分数，你需要这样执行： ZRANGE user_scores 0 10 WITHSCORES Agora Games就是一个很好的例子，用Ruby实现的，它的排行榜就是使用Redis来存储数据的，你可以在这里看到。
    （5）、发布/订阅 
     最后（但肯定不是最不重要的）是Redis的发布/订阅功能。发布/订阅的使用场景确实非常多。我已看见人们在社交网络连接中使用，还可作为基于发布/订阅的脚本触发器，甚至用Redis的发布/订阅功能来建立聊天系统！
    
    redis做分布式锁
    
    redis中过期的数据处理策略?redis中单线程的优势?说说看redis中io的模型?
    定时、惰性、定期删除
    https://blog.csdn.net/chen0613/article/details/80748877
    https://www.cnblogs.com/shamo89/p/8352084.html
    
    redis快的原因： https://blog.csdn.net/chenyao1994/article/details/79491337
                  1.完全基于内存，绝大部分请求是纯粹的内存操作，非常快速
                  2.数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的；
                  3.采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；
                  4.使用多路I/O复用模型，非阻塞IO；
                  5.使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；  
    
    单进程单线程好处
        代码更清晰，处理逻辑更简单
        不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗
        不存在多进程或者多线程导致的切换而消耗CPU
    io模型：I/O多路复用技术 https://blog.csdn.net/weixin_44100455/article/details/88956574
    通过一个线程就可以管理多个socket，只有当socket真正有读写事件发生才会占用资源来进行实际的读写操作ect/epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。
    现在操作系统多路复用API已经不再使用select系统调用，而改用epoll（Linux）和kqueue（FressBSD和MacOS）
    
    主从复制的作用 
        数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。
        故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。
        负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。
        读写分离：可以用于实现读写分离，主库写、从库读，读写分离不仅可以提高服务器的负载能力，同时可根据需求的变化，改变从库的数量；
        高可用基石：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。
    
    
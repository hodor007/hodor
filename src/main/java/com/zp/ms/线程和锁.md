线程和锁

    线程：
    1.实现多线程的方式
        一、继承Thread类
        二、实现Runnable接口
        三、实现Callable接口
        
    2.线程的生命周期 （https://www.cnblogs.com/li666/p/11130232.html）
      （1）新建：当一个Thread类或其子类的对象被声明并创建时。新生的线程对象属于新建状态。    
      （2）就绪：处于新建状态的线程执行start()方法后，进入线程队列等待CPU时间片，该状态具备了运行的状态，只是没有分配到CPU资源。    
      （3）运行：当就绪的线程分配到CPU资源便进入运行状态，run()方法定义了线程的操作。  
      （4）阻塞：在某种特殊情况下，被人为挂起或执行输入输出操作时，让出CPU并临时终止自己的的执行，进入阻塞状态。
      （5）死亡：当线程执行完自己的操作或提前被强制性的终止或出现异常导致结束，会进入死亡状态。
      
    3.volatile关键字的作用（从实践角度而言，volatile的一个重要作用就是和CAS结合，保证了原子性）
        一、多线程之间的可见性
        二、禁止指令重排序
        
    4.cas 属于乐观锁 （https://blog.csdn.net/u011506543/article/details/82392338）
    CAS，全称为Compare and Swap，即比较-替换。假设有三个操作数：内存值V、旧的预期值A、要修改的新值B，当且仅当预期值A和内存值V相同时，才会将内存值修改为B并返回true，否则什么都不做并返回false。
    当然CAS一定要volatile变量配合，这样才能保证每次拿到的变量是主内存中最新的那个值，否则旧的预期值A对某条线程来说，永远是一个不会变的值A，只要某次CAS操作失败，永远都不可能成功。
    
    5.sleep方法和wait方法有什么区别 
        一、sleep是线程类（Thread）的方法，导致此线程暂停执行指定时间，给执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复。调用sleep不会释放对象锁。
        二、wait是Object类的方法，对此对象调用wait方法导致本线程放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象发出notify方法（或notifyAll）后本线程才进入对象锁定池准备获得对象锁进入运行状态。
        
    6.ThreadLocal  在线程中存放一些就像session的这种特征变量，会针对不同的线程，有不同的值。
    
    7.线程池
    避免频繁地创建和销毁线程，达到线程对象的重用。在java.util.concurrent包中我们能找到线程池的定义，其中ThreadPoolExecutor是我们线程池核心类
    
    
    锁：
    1.乐观锁和悲观锁
        1）乐观锁：就像它的名字一样，对于并发间操作产生的线程安全问题持乐观状态，乐观锁认为竞争不总是会发生，因此它不需要持有锁，将比较-替换这两个动作作为一个原子操作尝试去修改内存中的变量，如果失败则表示发生冲突，那么就应该有相应的重试逻辑。
        2）悲观锁：还是像它的名字一样，对于并发间操作产生的线程安全问题持悲观状态，悲观锁认为竞争总是会发生，因此每次对某资源进行操作时，都会持有一个独占的锁，就像synchronized，不管三七二十一，直接上了锁就操作资源了。
    
    2.线程同步的几种方式
    synchronized修饰
    volatile实现同步（只能保证可见性，不能保证原子性）
    使用局部变量ThreadLocal
    使用原子类（AtomicInteger、AtomicBoolean……）
    使用Lock
    使用容器类（BlockingQueue、ConcurrentHashMap）
    
    3.synchronized和java.util.concurrent.locks.Lock的异同
      1.首先synchronized是java内置关键字，在jvm层面，Lock是个java类；    
      2.synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁；     
      3.synchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，Lock需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁；    
      4.用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了；
    
    5.synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可中断、可公平（两者皆可）
    
    4.死锁产生的四个条件
      互斥条件：资源是独占的且排他使用，进程互斥使用资源，即任意时刻一个资源只能给一个进程使用，其他进程若申请一个资源，而该资源被另一进程占有时，则申请者等待直到资源被占有者释放。
      不可剥夺条件：进程所获得的资源在未使用完毕之前，不被其他进程强行剥夺，而只能由获得该资源的进程资源释放。
      请求和保持条件：进程每次申请它所需要的一部分资源，在申请新的资源的同时，继续占用已分配到的资源。
      循环等待条件：在发生死锁时必然存在一个进程等待队列{P1,P2,…,Pn},其中P1等待P2占有的资源，P2等待P3占有的资源，…，Pn等待P1占有的资源，形成一个进程等待环路，环路中每一个进程所占有的资源同时被另一个申请，也就是前一个进程占有后一个进程所深情地资源
      
    5.分布式锁 https://blog.csdn.net/xlgen157387/article/details/79036337 
     zookeper分布式：https://www.cnblogs.com/toov5/p/9899489.html znode节点可以是持久（persistent）节点，还可以是临时(ephemeral)节点。持久节点node，如/path 只能通过delete命令进行删除，而临时节点相反，
     当创建临时节点的客户端崩溃或者关闭了与Zookeeper的连接时，这个节点就会被删除
    
    6.Thread.Sleep(0)的作用，就是“触发操作系统立刻重新进行一次CPU竞争”。线程直接回到就绪队列,竞争的结果也许是当前线程仍然获得CPU控制权，也许会换成别的线程获得CPU控制权。
    我们在大循环里面经常会写一句Thread.Sleep(0) ，因为这样就给了其他线程获得CPU控制权的权力，这样一些功能就不会假死在那里
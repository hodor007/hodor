数据库

    事务：
        事务及事务隔离级别https://www.cnblogs.com/xrq730/p/5087378.html 
        1、原子性
        即不可分割，事务要么全部被执行，要么全部不执行。如果事务的所有子事务全部提交成功，则所有的数据库操作被提交，数据库状态发生变化；如果有子事务失败，则其他子事务的数据库操作被回滚，即数据库回到事务执行前的状态，不会发生状态转换
        2、一致性
        事务的执行使得数据库从一种正确状态转换成另外一种正确状态
        3、隔离性
        在事务正确提交之前，不允许把事务对该数据的改变提供给任何其他事务，即在事务正确提交之前，它可能的结果不应该显示给其他事务
        4、持久性
        事务正确提交之后，其结果将永远保存在数据库之中，即使在事务提交之后有了其他故障，事务的处理结果也会得到保存
        
        事务并发的问题
        1、脏读  隔离的具体行为取决于隔离级别设置，默认的隔离级别满足不允许脏读，也就是满足我们经常看到的对事务的隔离性的说明的这句
        所谓脏读，所谓的脏读，其实就是读到了别的事务回滚前的脏数据。比如事务B执行过程中修改了数据X，在未提交前，事务A读取了X，而事务B却回滚了，这样事务A就形成了脏读。       
        2、不可重复读     
        所谓不可重复读，就是指在一个事务里面读取了两次某个数据，读出来的数据不一致。还是以银行取钱为例，事务A开启事务-->查出银行卡余额为1000元，此时切换到事务B事务B开启事务-->事务B取走100元-->提交，数据库里面余额变为900元，此时切换回事务A，事务A再查一次查出账户余额为900元，这样对事务A而言，在同一个事务内两次读取账户余额数据不一致，这就是不可重复读。        
        3、幻读        
        所谓幻读，就是指在一个事务里面的操作中发现了未被操作的数据。比如学生信息，事务A开启事务-->修改所有学生当天签到状况为false，此时切换到事务B，事务B开启事务-->事务B插入了一条学生数据，此时切换回事务A，事务A提交的时候发现了一条自己没有修改过的数据，这就是幻读，就好像发生了幻觉一样。幻读出现的前提是并发的事务中有事务发生了插入、删除操作。
        
        Tips:
        1.多个事务不会阻塞；
        2.update会加锁，在事务中也是，相当于会使整个事务加锁，如果另一个事务update了同一张表的数据，如果update的where条件带索引，那是锁行，不然锁表,另一个事务需要等待前面的事务结束锁释放,才会继续update；
        3.事务中查询不会加锁；
        
        使用注意:
        1.@Transactional 注解标识的方法，处理过程尽量的简单。尤其是带锁的事务方法，能不放在事务里面的最好不要放在事务里面。可以将常规的数据库查询操作放在事务前面进行，而事务内进行增、删、改、加锁查询(类似select … for update)等操作。
        2.@Transactional 注解标注的方法中不要出现网络调用、比较耗时的处理程序，因为，事务中数据库连接是不会释放的，如果每个事务的处理时间都非常长，那么宝贵的数据库连接资源将很快被耗尽。
        
        @Transactional失效原因:
        1.@Transactional 注解应该只被应用到 public 方法上，这是由 Spring AOP 的本质决定的。如果你在 protected、private 或者默认可见性的方法上使用 @Transactional 注解，这将被忽略，也不会抛出任何异常。
        2.默认情况下，只有来自外部的方法调用才会被AOP代理捕获，也就是，类内部方法调用本类内部的其他方法并不会引起事务行为，即使被调用方法使用@Transactional注解进行修饰。

    数据库优化：
        设计数据库时：数据库表、字段的设计，存储引擎，分区，分表
        利用好MySQL自身提供的功能，如索引等
        横向扩展：MySQL集群、负载均衡、读写分离
        SQL语句的优化（收效甚微）
        
        sql语句的优化：
            1.严禁左模糊或者全模糊
            2.负向条件查询不能使用索引，可以优化为 in 查询
            3.建联合索引的时候，区分度最高的字段在最左边
            4.把计算放到业务层而不是数据库层
            5.强制类型转换会全表扫描
            6.更新十分频繁、数据区分度不高的字段上不宜建立索引。
              更新会变更 B+ 树，更新频繁的字段建立索引会大大降低数据库性能。          
              “性别”这种区分度不大的属性，建立索引是没有什么意义的，不能有效过滤数据，性能与全表扫描类似。          
              一般区分度在80%以上的时候就可以建立索引，区分度可以使用 count(distinct(列名))/count(*) 来计算。
            7.如果有 order by、group by 的场景，请注意利用索引的有序性。
              order     by 最后的字段是组合索引的一部分，并且放在索引组合顺序的最后，避免出现     file_sort 的情况，影响查询性能。
              例如对于语句 where a=? and b=? order by     c，可以建立联合索引(a,b,c)。
              如果索引中有范围查找，那么索引有序性无法利用，如 WHERE     a>10 ORDER BY b;，索引(a,b)无法排序。
            8.建立索引的列，不允许为 null。
            9。超过三个表最好不要 join。
                需要 join 的字段，数据类型必须一致，多表关联查询时，保证被关联的字段需要有索引。
            10.如果明确知道只有一条结果返回，limit 1 能够提高效率。
            11.SQL 性能优化 explain 中的 type：至少要达到 range 级别，要求是 ref 级别，如果可以是 consts 最好。
               consts：单表中最多只有一个匹配行（主键或者唯一索引），在优化阶段即可读取到数据。
               ref：使用普通的索引（Normal Index）。
               range：对索引进行范围检索。
               当 type=index 时，索引物理文件全扫，速度非常慢。
            12.尽量避免使用or，会导致数据库引擎放弃索引进行全表扫描
    数据库索引：
        数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。
        为表设置索引要付出代价的：一是增加了数据库的存储空间，二是在插入和修改数据时要花费较多的时间(因为索引也要随之变动)。


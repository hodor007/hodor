集合实现原理 http://blog.csdn.net/qq_25868207/article/details/55259978
    ArrayList
        大小可变数组的实现,不同步，区别于vector
    LinkedList
        LinkedList是List接口的双向链表非同步实现，并允许包括null在内的所有元素。
    HashSet
        HashSet由哈希表(实际上是一个HashMap实例)支持，不保证set的迭代顺序，并允许使用null元素。不允许重复。
    HashMap https://www.jianshu.com/p/e2f75c8cce01
    1. HashMap是基于哈希表的Map接口的非同步实现，允许使用null值和null键，但不保证映射的顺序。（Hashtable 同步 ）
    2. 底层使用数组实现，数组中每一项是个单向链表，即数组和链表的结合体；当链表长度大于一定阈值时，链表转换为红黑树（ 是一种近似平衡的二叉查找树），这样减少链表查询时间。
    3. HashMap在底层将key-value当成一个整体进行处理，这个整体就是一个Node对象。HashMap底层采用一个Node[]数组来保存所有的key-value对，当需要存储一个Node对象时，会根据key的hash算法来决定其在数组中的存储位置，在根据equals方法决定其在该数组位置上的链表中的存储位置；当需要取出一个Node时，也会根据key的hash算法找到其在数组中的存储位置，再根据equals方法从该位置上的链表中取出该Node。
    4. HashMap进行数组扩容需要重新计算扩容后每个元素在数组中的位置，很耗性能
    CurrentHashMap （ ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。Segment是一种可重入锁ReentrantLock，在ConcurrentHashMap里扮演锁的角色，HashEntry则用于存储键值对数据。）https://www.cnblogs.com/ITtangtang/p/3948786.html
    1. ConcurrentHashMap允许多个修改操作并发进行，其关键在于使用了锁分离技术。
    2. 它使用了多个锁来控制对hash表的不同段进行的修改，每个段其实就是一个小的hashtable，它们有自己的锁。只要多个并发发生在不同的段上，它们就可以并发进行。
    3. ConcurrentHashMap在底层将key-value当成一个整体进行处理，这个整体就是一个Entry对象。Hashtable底层采用一个Entry[]数组来保存所有的key-value对，当需要存储一个Entry对象时，会根据key的hash算法来决定其在数组中的存储位置，在根据equals方法决定其在该数组位置上的链表中的存储位置；当需要取出一个Entry时，也会根据key的hash算法找到其在数组中的存储位置，再根据equals方法从该位置上的链表中取出该Entry。
    4. 与HashMap不同的是，ConcurrentHashMap使用多个子Hash表，也就是段(Segment)
    5. ConcurrentHashMap完全允许多个读操作并发进行，读操作并不需要加锁。如果使用传统的技术，如HashMap中的实现，如果允许可以在hash链的中间添加或删除元素，读操作不加锁将得到不一致的数据。ConcurrentHashMap实现技术是保证HashEntry几乎是不可变的。
    
    
        


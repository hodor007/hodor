jvm 和 类加载基本概率说明
             1.类加载子系统：负责从文件系统或网络中加载Class信息，加载的信息存放在一块称之为方法区的内存空间。
             2.方法区：就是存放类信息（ 类的版本，字段，方法，接口）、常量信息、常量池信息（ 字面量和符号引用）、包括字符串字面量和数字常量等。
             3.java堆：在Java虚拟机启动的时候建立java堆，它是java程序最主要的内存工作区域，几乎所有的对象都存放到java堆中，堆空间是所有线程共享的。
             4.直接内存：Java的NIO库允许Java程序使用直接内存，从而提高性能，通常直接内存速度会优于java堆，读写频繁的场合可能会考虑使用。
             5.每个虚拟机线程都有一个私有的栈，一个线程的java栈在线程创建的时候被创建，java栈中保存着局部变量、方法参数、同时java的方法调用、返回值等。 栈中存的是基本数据类型和堆中对象的引用。
             6.本地方法栈和java栈非常类似，最大不同为本地方法栈用于本地方法调用，java虚拟机允许java调用本地方法（通常使用c编写）
             7.垃圾回收系统是java的核心，也是必不可少的，java有一套自己进行垃圾清理机制，开发人员无需手工清理，我们稍后详细说明。
             8.PC(Program Counter)寄存器也是每个线程私有的空间，java虚拟机会为每个线程创建PC寄存器，在任意时刻，一个java线程总是在执行一个方法，这个方法被称为当前方法，如果当前方法不是本地方法，则PC寄存器值为undefined,寄存器存放如当前执行环境指针、程序计数器、操作栈指针、计算的变量指针等信息
             9.虚拟机最核心的组件就是执行引擎了，他负责执行虚拟机的字节码，一般会先进行编译成机器码后执行
         
           
         堆、栈、方法区概念和联系
             堆解决的是数据存储问题，即数据怎么放、放在哪儿。
             栈解决程序的运行问题，即程序如何执行，或者说如何处理数据
             方法区（Perm）则是辅助堆栈的块永久区，解决堆栈信息的产生，是先决条件。
             我们创建一个新的对象，User：那么User类的一些信息（类信息、静态信息都存在于方法区中），当User类被实例化出来之后。被存储到java堆中，一块内存空间，当我们去使用的时候，都是使用User对象的引用，那如User user=new User();这里的user就是存放在java栈中的，即User真是对象的一个引用。
         垃圾回收机制
             根据垃圾回收机制不同，Java堆有可能拥有不同的结构，最常见的就是将整个java堆分成新生代和老年代。其中新生代存放新生的对象或者年龄不大的对象，老年代则存放老年对象。
             新生代分为Eden区、s0区、s1区，s0和s1也被称为from和to区域，他们是两块大小相等并且可以互换角色的空间。
             绝大多数情况下对象首先分配在Eden区，在一次新生代回收后，如果对象还存活，则进入s0或者s1区，之后每经过一次新生代回收，如果对象存活则他的年龄就加1，当对象达到一定的年龄后，则进入老年代
         垃圾回收算法
             标记清除法：就是分为标记和清除两个阶段进行处理内存中的对象， 此算法执行分两阶段。第一阶段从引用根节点开始标记所有被引用的对象，第二阶段遍历整个堆，把未标记的对象清除，这种方式有很大弊端，就是空间碎片问题，垃圾回收后的空间是不连续的，不连续的内存空间的工作效率要低于连续的内存空间。
         基本思想是通过一系列称为“GC roots”的对象作为起始点，可以作为根节点的是：
           虚拟机栈（栈帧中的本地变量表）中引用的对象
           本地方法栈中JNI（即一般说的Native方法）引用的对象
           方法区中类静态属性引用的对象
                   方法区中常量引用的对象
             复制算法：其核心思想就是将内存空间分为两块，每次只使用其中一块，在垃圾回收时，将正在使用的内存中的存留对象复制到未被使用的内存块中区，之后去清除之前正在使用的内存块中所有的对象，反复去交换两个内存的角色，完成垃圾收集。（java中新生代的from和to空间就是使用这个算法）
             标记压缩法：标记压缩法在标记清除基础上做了优化，把存货的对象压缩到内存一段，而后进行垃圾清理（java中老年代使用的就是标记压缩法）
         新生代和老年代不同算法原因：新生代GC比较频繁，回收的多
             分代算法：就是根据对象的特点把内存分为N块，而后根据每个内存的特点使用不同的算法。对于新生代和老年代来说，新生代回收频率较低，但耗时会相对较长，所以应该尽量减少老年代的GC。
             分区算法：器主要是将整合内存分为N多个小的独立空间，每个空间都可以独立使用，这样细粒度的控制一次回收都少个小空间和那些个小空间，而不是对整合空间进行GC，从而提升性能，并减少GC的停顿时间（垃圾回收时，为了让来及回收期高效运行，会要求系统进入一个停顿的状态）
         
         堆分配参数 (https://www.cnblogs.com/redcreen/archive/2011/05/04/2037057.html)
         -XX:+PrintGC 虚拟机启动后，只要遇到GC就会打印日志
         -XX:+UseSerialGC 配置串行回收器
         -XX:+PrintGCDetails 可以查看详情信息，包括各个区的情况
         -Xms:设置java程序启动时初始堆大小
         -Xmx:设置java程序能够获得的最大堆大小
         -XX:+PrintCommandLineFlags 可以将虚拟机的参数输出
         在实际工作中，可以直接将初始的堆大小与最大堆大小设置相等，这样的好处是可以减少程序运行时的垃圾回收次数，从而提交性能。
         -Xmn:可以设置新生代大小。新生代大小一般会设置整个堆空间的1/3到1/4左右
         不同的堆分布情况，对系统执行会产生一定的影响
         -Xss:来指定线程的最大栈空间，整个参数也直接决定函数可调用的最大深度
         -XX:MaxTenuringThreshold,默认情况下为15，可以指定新生代对象经过多少次回收后进入老年代，另外大对象（新生代Eden区无法装入时，也直接进入老年代），JVM里有个参数可以设置对象的大小超过在指定的大小之后，直接晋升老年代。-XX:PretenureSizeThreshold
         
         TLAB全称是Thread Local Allocation Buffer 即线程本地分配缓存，从名字上看是一个线程专用的内存分配区域，是为了加速对象分配而生的，每一个线程都会产生一个TLAB，该线程独享的工作区域，java虚拟机使用这种TLAB区来避免多线程冲突问题，提高了对象分配的效率。TLAB空间一般不会太大，当大对象无法再TLAB分配时，则直接分配到堆上。
         https://blog.csdn.net/xiaomingdetianxia/article/details/77688945
         
         垃圾回收器
             串行垃圾回收器
                 值单线程进行垃圾回收的回收器，每次回收时，串行回收器只有一个工作线程，对于并行能力较弱的计算机来说，串行回收器的专注性和独占性往往有更好的性能表现，串行回收器可以在新生代和老年代使用。使用-XX:+UseSerialGC参数可以设置使用新生代串行回收器和老年代串行回收器。
             并行垃圾回收期
                 可以使用多个线程同时进行垃圾回收，对于计算能力强的计算机，可以优先缩短回收时间
                 使用-XX:+UseParNewGC新生代ParNew回收器，老年代则使用串行回收器，ParNew回收器工作时的线程数量可以使用-XX:ParallelGCThreads参数指定，一般最好和计算机的CPU相当，避免过多的线程影响性能。
             CMS回收器（主流）
                 Concurrent Mark Sweep意为并发标记清除，他使用的是标记清除法，主要是关注系统停顿时间
         使用-XX：+UseConcMarkSweepGC进行设置
         使用-XX：ConGCThreads设置并发线程数量
         CMS并不是独占的回收器，也就是说CMS回收的过程中，应用程序任然在不停的工作，又会有新的垃圾不断产生，所以在使用CMSDE过程中应该确保应用程序的内存足够使用，CMS不会等到应用程序饱和的时候才去回收垃圾，而是在某一阈值的时候开始回收，回收阈值可用指定的参数进行设置，-XX:CMSInitiatingOccupancyFraction来指定，默认为68，也就是说当老年代的空间使用率达到68%的时候，会执行CMS回收，如果内存使用增长的很快，在CMS执行的过程中，已经出现了内存不足的情况，此时CMS回收就会失败，虚拟机将启动老年代串行回收器进行垃圾回收，这会导致应用程序中断，知道垃圾回收完成后才会正常工作，这个GC的停顿时间可能较长，所以-XX:CMSInitiatingOccupancyFraction的设置要根据实际的情况。之前我们在学习算法的时候说过，标记清除法有个缺点就是存在内存碎片的问题，那么CMS有个参数设置-XX:+UseCMSCompactAtFullCollection可以使CMS回收完成后进行一次碎片清理，-XX:CMSFullGCsBeforeCompacation参数可以设置进行多少次CMS回收之后，对内存进行一个压缩。
             G1回收器
         
         类加载机制
         类加载： 类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。
         类加载的过程包括了加载、验证、准备、解析、初始化五个阶段， 这里的几个阶段是按顺序开始，而不是按顺序进行或完成。
         加载：查找并加载类的二进制数据
            加载时类加载过程的第一个阶段，在加载阶段，虚拟机需要完成以下三件事情：
             1、通过一个类的全限定名来获取其定义的二进制字节流。
             2、将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
             3、在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。
             相对于类加载的其他阶段而言，加载阶段（准确地说，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。
             加载阶段完成后，虚拟机外部的 二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在Java堆中也创建一个java.lang.Class类的对象，这样便可以通过该对象访问方法区中的这些数据。
         •连接
          – 验证：确保被加载的类的正确性
         验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致会完成4个阶段的检验动作：
         文件格式验证：验证字节流是否符合Class文件格式的规范；例如：是否以0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。
         元数据验证：对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了java.lang.Object之外。
         字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。
         符号引用验证：确保解析动作能正确执行。
         验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用-Xverifynone参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。
          
          – 准备：为类的静态变量分配内存，并将其初始化为默认值
            准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：
             1、这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。
             2、这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。
            假设一个类变量的定义为：public static int value = 3；
            那么变量value在准备阶段过后的初始值为0，而不是3，因为这时候尚未开始执行任何Java方法，而把value赋值为3的putstatic指令是在程序编译后，存放于类构造器<clinit>（）方法之中的，所以把value赋值为3的动作将在初始化阶段才会执行。
         
         · 这里还需要注意如下几点：
         · 对基本数据类型来说，对于类变量（static）和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值，而对于局部变量来说，在使用前必须显式地为其赋值，否则编译时不通过。
         · 对于同时被static和final修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；而只被final修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值。
         · 对于引用数据类型reference来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的零值，即null。
         · 如果在数组初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的零值。
         
             3、如果类字段的字段属性表中存在ConstantValue属性，即同时被final和static修饰，那么在准备阶段变量value就会被初始化为ConstValue属性所指定的值。
            假设上面的类变量value被定义为： public static final int value = 3；
            编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为3。回忆上一篇博文中对象被动引用的第2个例子，便是这种情况。我们可以理解为static final常量在编译期就将其结果放入了调用它的类的常量池中
          
          – 解析：把类中的符号引用转换为直接引用
         解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。符号引用就是一组符号来描述目标，可以是任何字面量。
         直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。
         •初始化
          初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式：
           ①声明类变量是指定初始值
           ②使用静态代码块为类变量指定初始值
          JVM初始化步骤
          1、假如这个类还没有被加载和连接，则程序先加载并连接该类
          2、假如该类的直接父类还没有被初始化，则先初始化其直接父类
          3、假如类中有初始化语句，则系统依次执行这些初始化语句
         类初始化时机：只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种：
         – 创建类的实例，也就是new的方式
         – 访问某个类或接口的静态变量，或者对该静态变量赋值
         – 调用类的静态方法
         – 反射（如Class.forName(“com.shengsiyuan.Test”)）
         – 初始化某个类的子类，则其父类也会被初始化
         – Java虚拟机启动时被标明为启动类的类（Java Test），直接使用java.exe命令来运行某个主类
          
         加载器
         启动类加载器 Bootstrap ClassLoader：加载<JAVA_HOME>\lib目录下核心库
         扩展类加载器 Extension ClassLoader：加载<JAVA_HOME>\lib\ext目录下扩展包
         应用程序类加载器 Application ClassLoader：  加载用户路径(classpath)上指定的类库
         自定义加载器
         
         加载机制：双亲委派机制
            1-类加载器收到类加载的请求；
            2-把这个请求委托给父加载器去完成，一直向上委托，直到启动类加载器；
            3-启动器加载器检查能不能加载（使用findClass()方法），能就加载（结束）；否则，抛出异常，通知子加载器进行加载。
            4-重复步骤三；
         具备了带有优先级的层次关系，确保了在各种加载环境的加载顺序， 避免类的重复加载  
         保证了运行的安全性
         
         
         
         
         
             
